第 (i, j) 位置就是你分组的第 i + j 组，设 n = i + j, 在前一半的分组中，每一个分组数字的个数都比前一个分组的数字个数多 1 个。即每组的数字个数为： 
第 0 组： 1 
第 1 组： 2 
第 2 组： 3 
... 
第 n 组： n + 1. 

因此，在第 n 组之前共有  1 + 2 + 3 + 4 + ... + n 个数字，根据累加公式即： n * (n + 1) / 2。 
所以，第 n 组的第一个数就是前面 n - 1 组的数字个数之后的那个数。即  v = n * (n + 1) / 2 + 1; 

在第 n 组中，如果 n 为奇数( n % 2 != 0)，则从左向右增加， v += j; 否则从右向左增加  v += (n - j), 而 (n - j) 就是 i. 

所以有代码： 
              else 
            { 
                v = n * (n + 1) / 2 + 1; 
                v += n % 2 ? j : i; 
            } 

在后一半的分组中，和前面相反，是从维数的平方向后减，情况复杂点，原理相同






功能：打印出一个维数为N的蛇形数组。如5维
1  3  4  10 11
2  5  9  12 19
6  8  13 18 20
7  14 17 21 24
15 16 22 23 25
算法：借鉴杨辉三角思想,依照顺序分组，如下
第0组：（0，0）                                 数字：1
第1组：（0，1）（1，0），                       数字：2 3
第2组；（0，2）（1，1）（2，0）                 数字: 4 5 6
第3组：（0，3）（1，2）（2，1）（3，0）         数字：7 8 9 10
....
通过总结得：如果维数位n，那么总的组数为n+n-1

假设横纵坐标i，j的，组号为k，数number取值范围从1---n^2。
则有对每一组有 i+j=k，那么开始遍历数组，只要i与j的和恰好等于K
就赋值相应的number值。

*/
int const n = 5;
void printf_snakearray()
{
    int n_splits = n + n-1;//组数
    int k = 0;
    int i,j;
    int number=1;//
    int map[n][n]={0};
    while (k<n_splits)
    {
        for (i=0;i<n;i++)
        {
            for (j=0;j<n;j++)
            {
                if (i+j==k)
                {
                    if (k%2==0)//用来蛇形控制走向
                    {
                        map[i][j] = number;
                    }
                    else
                        map[j][i] = number;
                    
                    number ++;
                }
            }
        }
        k++;
        
    }
    for (i=0;i<n;i++)
    {
        for (j=0;j<n;j++)
        {
            printf("%4d ",map[i][j]);
        }
        printf("\n");
    }
}

